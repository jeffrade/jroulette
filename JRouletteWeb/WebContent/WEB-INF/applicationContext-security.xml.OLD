<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p" 
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:jee="http://www.springframework.org/schema/jee" 
		xmlns:tx="http://www.springframework.org/schema/tx"
		xmlns:security="http://www.springframework.org/schema/security"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
			http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
			http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd
			http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
			http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-2.0.6.xsd">
			
	<import resource="jroulette-servlet.xml" />
    
    <security:global-method-security secured-annotations="enabled" />
    
    <security:http auto-config="true">
	    <security:authenticatin-provider>
	    	<security:jdbc-user-service data-source-ref="dataSource"
	    		authorities-by-username-query="SELECT ju.email as username, a.authority
					FROM authorities a jroulette_user ju
					WHERE a.juser_id = ju.id AND email=?" />
	    </security:authenticatin-provider>
	    
    	<security:intercept-url pattern="/admin/*" access="ROLE_ADMIN" />
    	<security:intercept-url pattern="/*" access="ROLE_ADMIN,ROLE_USER" /> <!-- Maybe need ROLE_GUEST as well -->
    	
    	<security:form-login login-page="login.htm" />
    </security:http>
    
    

    <!-- ############ Security Filter Beans ############ -->
    <bean id="requestDumperFilter" class="filters.RequestDumperFilter"></bean>
    
    <!-- Which Filter to use below? -->
    <bean id="httpRequestFilter" class="org.springframework.security.adapters.HttpRequestIntegrationFilter"></bean>
    <bean id="httpSessionContextFilter" class="org.springframework.security.context.HttpSessionContextIntegrationFilter"></bean> 
    
    <bean id="springFilterChainProxy" class="org.springframework.security.util.FilterChainProxy">
     	<security:filter-chain-map path-type="ant">
        	<security:filter-chain pattern="/private/**" filters="requestDumperFilter"/>
     		<security:filter-chain pattern="/**" filters="none"/>
     	</security:filter-chain-map>
    </bean>

	<!-- ############ Security Beans ############ -->
    <bean id="authenticationManager" class="org.springframework.security.providers.ProviderManager">
		<property name="providers">
			<list>
				<ref bean="daoAuthenticationProvider"/>
			</list>
		</property>
	</bean>

	<bean id="daoAuthenticationProvider" class="org.springframework.security.providers.dao.DaoAuthenticationProvider">
		<property name="userDetailsService" ref="userDetailsService"/>
		<property name="passwordEncoder">
			<bean class="org.springframework.security.providers.encoding.Md5PasswordEncoder" />
		</property>
		<property name="saltSource">
			<bean class="org.springframework.security.providers.dao.salt.SystemWideSaltSource">
				<property name="systemWideSalt" value="ABC123XYZ789" />
			</bean>
		</property>
		<!-- Default is NO caching - will always get from DB -->
		<!--<property name="userCache">
			<bean class="org.springframework.security.providers.dao.cache.EhCacheBasedUserCache">
				<property name="cache" ref="ehcache" />
			</bean>
		</property>-->
	</bean>
	
	<bean id="userDetailsService" class="org.springframework.security.userdetails.jdbc.JdbcDaoImpl">
		<property name="dataSource" ref="dataSource"/>
		<property name="usersByUsernameQuery">
			<value>
				SELECT email as username, password, active as enabled
				FROM jroulette_user
				WHERE email=?
			</value>
		</property>
		<property name="authoritiesByUsernameQuery">
			<value>
				SELECT ju.email as username, a.authority
				FROM authorities a jroulette_user ju
				WHERE a.juser_id = ju.id AND email=?
			</value>
		</property>
	</bean>
	
	<bean id="accessDecisionManager" class="org.springframework.security.vote.UnanimousBased">
		<property name="decisionVoters">
			<list>
				<ref bean="roleVoter"/>
			</list>
		</property>
		<property name="allowIfAllAbstainDecisions" value="false" /> <!-- default behavior -->
		<!-- Spring In Action p.275
		By setting allowIfAllAbstain to true, you are establishing a policy of “silence is
		consent.” In other words, if all voters abstain from voting, access is granted as if
		they had voted to grant access.
		 -->
	</bean>
	
	<bean id="roleVoter" class="org.springframework.security.vote.RoleVoter">
		<property name="rolePrefix" value="ROLE_" /> <!-- ROLE_ is default, added as an FYI -->
		<!-- Spring In Action p.274
		The way that RoleVoter decides on its vote is by simply comparing all of the
		configuration attributes of the secured resource (that are prefixed with ROLE_)
		with all of the authorities granted to the authenticated user. If RoleVoter finds a
		match, it will cast an ACCESS_GRANTED vote. Otherwise, it will cast an ACCESS_
		DENIED vote.
		The RoleVoter will only abstain from voting when the authorities required for
		access are not prefixed with ROLE_. For example, if the secured resource only
		requires non-role authorities (such as CREATE_USER), the RoleVoter will abstain
		from voting.
		 -->
	</bean>
	
	<!--<bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheFactoryBean">
		<property name="cacheManager" ref="cacheManager" />
		<property name="cacheName" value="userCache" />
	</bean>
	
	<bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">
		<property name="configLocation" value="classpath:net.jroulette.context.ehcache.xml" />
	</bean>-->





	<!-- ###################### MISC Beans ###################### -->
    <bean id="XXXspringFilterChainProxy" class="org.springframework.security.util.FilterChainProxy">
    <!-- Below is deprecated:
		<property name="filterInvocationDefinitionSource">
			<value>
				CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
				PATTERN_TYPE_APACHE_ANT
				/**=httpSessionIntegrationFilter,
				authenticationProcessingFilter,
				exceptionTranslationFilter,
				filterSecurityInterceptor
			</value>
		</property>
		-->
		<!-- JAVADOC
		Sets the mapping of URL patterns to filter chains.
		The map keys should be the paths and the values should be arrays of <tt>Filter</tt> objects.
		It's VERY important that the type of map used preserves ordering - the order in which the iterator
		returns the entries must be the same as the order they were added to the map, otherwise you have no way
		of guaranteeing that the most specific patterns are returned before the more general ones. So make sure
		the Map used is an instance of <tt>LinkedHashMap</tt> or an equivalent, rather than a plain <tt>HashMap</tt>, for
		example.
		@param filterChainMap the map of path Strings to <tt>Filter[]</tt>s.
		 -->
		 <property name="filterChainMap">
			<map>
				<entry>
					<key><value>/private/**</value></key>
					<list>
						<ref bean="requestDumperFilter"/>
					</list>
				</entry>
			</map>
		</property>
	</bean>

    <!-- Spring In Action Examples
    <bean id="fooFilter" class="com.roadrantz.FooFilter">
		<property name="bar" ref="bar" />
	</bean>
    --> 
    <!-- Spring In Action p.282
    <bean id="filterChainProxy" class="org.springframework.security.util.FilterChainProxy">
		<property name="filterInvocationDefinitionSource">
			<value>
				CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
				PATTERN_TYPE_APACHE_ANT
				/**=filter1,filter2,filter3
				
				Here, the /** pattern (in Ant, this means all URLs will match) is mapped to three filters. 
				The filter configured as the filter1 bean will be the outermost filter and will receive the
				request first. The filter2 bean is next. And the filter3 bean will be the inner-
				most bean and will be the last filter to receive the request before the actual
				secured resource is processed. When a response is returned, it flows in reverse	order, from filter3 to filter1.
				
			</value>
		</property>
	</bean>-->		
</beans>